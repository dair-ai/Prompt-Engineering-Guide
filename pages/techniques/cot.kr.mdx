# Chain-of-Thought Prompting

import {Screenshot} from 'components/screenshot'
import COT from '../../img/cot.png'
import ZEROCOT from '../../img/zero-cot.png'
import AUTOCOT from '../../img/auto-cot.png'


## Chain-of-Thought (CoT) Prompting

<Screenshot src={COT} alt="COT" />

이미지 출처: [Wei et al. (2022)](https://arxiv.org/abs/2201.11903)

[Wei et al. (2022)](https://arxiv.org/abs/2201.11903)에서 소개된 생각의 사슬(chain-of-thought, CoT) 프롬프트는 중간 추론 단계를 통해 복잡한 추론을 가능하게 합니다. 이를 단답형 프롬프트와 결합하면 응답하기 전에 추론이 필요한 복잡한 작업에서 더 나은 결과를 얻을 수 있습니다.

*Prompt:*
```
집합 {4, 8, 9, 15, 12, 2, 1}에서 홀수를 모두 더하면 짝수야.
답변: 홀수(9, 15, 1)를 모두 더하면 25가 돼. 위의 명제는 거짓이야.

집합 {17, 10, 19, 4, 8, 12, 24}에서 홀수를 모두 더하면 짝수야.
답변: 홀수(17, 19)를 모두 더하면 36이 돼. 위의 명제는 참이야.

집합 {16, 11, 14, 4, 8, 13, 24}에서 홀수를 모두 더하면 짝수야.
답변: 홀수(11, 13)를 모두 더하면 24가 돼. 위의 명제는 참이야.

집합 {17, 9, 10, 12, 13, 4, 2}에서 홀수를 모두 더하면 짝수야.
답변: 홀수(17, 9, 13)를 모두 더하면 39가 돼. 위의 명제는 거짓이야.

집합 {15, 32, 5, 13, 82, 7, 1}에서 홀수를 모두 더하면 짝수야.
답변:
```

*Output:*
```
홀수(15, 5, 13, 7, 1)를 모두 더하면 41이 돼. 위의 명제는 거짓이야.
```

와우! 추론 단계를 추가했을 때 완벽한 결과를 볼 수 있습니다. 사실 더 적은 수의 예시, 즉 하나의 예시만 추가해도 이 과제를 해결할 수 있습니다:

*Prompt:*
```
이 그룹의 홀수의 합은 짝수야: 4, 8, 9, 15, 12, 2, 1
A: 홀수(9, 15, 1)를 모두 더하면 25가 돼. 정답은 거짓이야.

이 그룹의 홀수의 합은 짝수야: 15, 32, 5, 13, 82, 7, 1
A:
```

*Output:*
```
홀수(15, 5, 13, 7, 1)를 모두 더하면 41이 돼. 답은 거짓이야.
```

논문의 저자들은 위와 같은 결과가 충분히 큰 대규모언어모델에서만 발생하는 특성이라고 주장한다는 점을 명심하세요.

## Zero-shot CoT Prompting

<Screenshot src={ZEROCOT} alt="Zero-shot COT" />

이미지 출처: [Kojima et al. (2022)](https://arxiv.org/abs/2205.11916)

최근에 나온 아이디어 중 하나로 제로샷 생각의 사슬\(zero-shot CoT\)이 있습니다. [zero-shot CoT](https://arxiv.org/abs/2205.11916) (Kojima et al. 2022) 원래의 프롬프트에 "단계별로 생각하기"를 추가하는 것이 핵심입니다. 간단한 문제를 풀고 모델이 어떻게 작동하는지 살펴봅시다:

*Prompt:*
```
나는 시장에 가서 사과 10개를 샀어. 사과 2개를 이웃에게 주고, 2개를 수리공에게 주었어. 그리고 사과 5개를 더 사서 1개는 내가 먹었어. 나는 몇 개의 사과를 가지고 있었니?
```

*Output:*
```
사과 11개
```

오답입니다! 위에서 제안한 "단계별로 생각하기"를 추가한 프롬프트로 시도해 보겠습니다.

*Prompt:*
```
나는 시장에 가서 사과 10개를 샀어. 나는 사과 2개를 이웃에게 주고, 2개를 수리공에게 주었어. 그리고 사과 5개를 더 사서 1개는 내가 먹었어. 사과가 몇 개나 남았니?

단계별로 생각해 보자.
```

*Output:*
```
먼저 사과 10개로 시작했어.
이웃에게 2개, 수리공에게 2개를 나누어 주었으므로 사과가 6개가 남았어.
그런 다음 사과 5개를 더 사서 이제 사과가 11개가 되었어.
마지막으로 사과 1개를 먹었으므로 사과 10개가 남게 돼.
```

이 간단한 프롬프트가 위와 같은 문제에 효과적이라는 점이 인상적입니다. 프롬프트에 사용할 예시가 그리 많지 않을 때 특히 유용합니다.

## Automatic Chain-of-Thought (Auto-CoT)

데모와 함께 생각의 사슬 프롬프트를 적용할 때, 이 과정은 효과적이고 다양한 예시를 수작업으로 포함합니다. 이러한 수작업은 차선의 해결책으로 이어질 수 있습니다. [Zhang 등(2022)](https://arxiv.org/abs/2210.03493)은 "단계별로 생각해보자"라는 프롬프트가 있는 대규모언어모델을 활용하여 데모를 위한 추론 사슬을 하나씩 생성함으로써 수작업을 없애는 접근 방식을 제안합니다. 이 자동 프로세스는 여전히 생성된 체인에 실수가 있을 수 있습니다. 실수로 인한 영향을 완화하기 위해서는 데모의 다양성이 중요합니다. 이 연구에서는 다양한 질문을 샘플링하고 데모를 구성하기 위한 추론 체인을 생성하는 Auto-CoT를 제안합니다.

Auto-CoT는 두 가지 주요 단계로 구성됩니다.

- 1단계): **질문 클러스터링\(question clustering\)**: 주어진 데이터 세트의 질문을 몇 개의 클러스터로 분할합니다.
- 2단계): **데모 샘플링\(demonstration sampling\)**: 각 클러스터에서 대표 질문을 선택하고 간단한 휴리스틱과 함께 제로샷 생각의 사슬(Zero-Shot-CoT)를 사용해 추론 체인을 생성합니다.

간단한 휴리스틱은 질문의 길이(예: 60개의 토큰)와 추론 단계 수(예: 5개의 추론 단계)가 될 수 있습니다. 이렇게 하면 모델이 간단하고 정확한 데모를 사용하도록 장려합니다.  

그 과정은 아래에 설명되어 있습니다.

<Screenshot src={AUTOCOT} alt="AUTOCOT" />

이미지 출처: [Zhang et al. (2022)](https://arxiv.org/abs/2210.03493)

Auto-CoT 코드는 [여기](https://github.com/amazon-science/auto-cot)에서 확인할 수 있습니다.